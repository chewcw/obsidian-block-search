# Plan: Implement Obsidian Block Search Plugin

A phased, modular implementation that transforms the template into a functional block search plugin. Start with core block parsing and searching logic, then layer in UI and commands, finally refining with settings.

## Implementation Steps

1. **Update manifest.json** with block-search ID, name "Block Search", description, and version alignment. Ensure `minAppVersion` matches capabilities.

2. **Create src/types.ts** defining `Block` interface (text, level, lineNumber, filePath, fileName) and `SearchResult` interface (block, matchScore).

3. **Create src/blocks/parser.ts** with `extractBlocksFromMarkdown(content: string, filePath: string): Block[]` that parses markdown lines, identifies bullet hierarchies, and returns block metadata.

4. **Create src/blocks/searcher.ts** with `searchBlocks(query: string, blocks: Block[]): SearchResult[]` (case-insensitive partial match), and `loadAllBlocks(app: App): Promise<Block[]>` that iterates vault files.

5. **Create src/ui/searchModal.ts** implementing a `SearchModal extends Modal` that opens on command, displays search box, renders results with highlighting, and handles "jump to note" interactions.

6. **Refactor src/main.ts** to remove sample commands/UI, add only the block-search command, and initialize the plugin cleanly.

7. **Update src/settings.ts** with `BlockSearchSettings` interface (e.g., `caseSensitive: boolean`) and defaults; no immediate UI changes needed if using simple defaults.

8. **Test locally** by copying `main.js`, `manifest.json`, `styles.css` to `~/.obsidian/plugins/block-search/` and reloading Obsidian.

## Further Considerations

### Block Parsing Strategy
- **Option A**: Regex approach (lines starting with `-`, `*`, `•`, indent-based hierarchy) for lightweight startup
  - **Pros**: Fast compilation, minimal dependencies, straightforward logic
  - **Cons**: Edge cases with nested indents, mixed bullet styles
- **Option B**: Use `remark` library for robust markdown AST parsing
  - **Pros**: Handles all markdown edge cases, future-proof
  - **Cons**: Adds ~30KB, slightly slower startup

**Recommendation**: Start with Option A (Regex). Migrate to remark if edge cases become problematic.

### Performance for Large Vaults
- **Option A**: On-demand block loading per search
  - **Pros**: No caching overhead, simple implementation
  - **Cons**: Slower for repeated searches, noticeable latency on large vaults (100+ notes)
- **Option B**: Lazy-loaded cache with file system event invalidation
  - **Pros**: Fast searches after initial load, responsive UX
  - **Cons**: More complex, requires careful cache invalidation

**Recommendation**: Start with Option A. Implement Option B if users report lag on vaults with 100+ notes.

### Search Result Ranking
- **Option A**: Equal weighting for all matches
  - **Pros**: Simple, predictable
  - **Cons**: Large result sets can be overwhelming
- **Option B**: Rank by file name match, block position, and context relevance
  - **Pros**: More intuitive results, better UX
  - **Cons**: Requires scoring logic and tuning

**Recommendation**: Start with Option A. Add ranking heuristics (exact file name matches first, then by line proximity) if result quality becomes an issue.

### UI Enhancements
- **Option A**: Modal-only interface with block text preview
  - **Pros**: Minimal CSS, clean MVP, fast to implement
  - **Cons**: Limited context visibility
- **Option B**: Side-by-side preview with syntax highlighting and block context
  - **Pros**: Better visibility, more polished UX
  - **Cons**: Requires additional CSS and layout logic

**Recommendation**: Start with Option A. Use `.obsidian-app` class inspection to style the modal consistently with Obsidian's theme.

## Module Responsibilities

- **parser.ts**: Extract blocks from markdown using regex or AST, return array of block objects with metadata (text, nesting level, line number, file path, file name)
- **searcher.ts**: Filter blocks by search query, handle case sensitivity, return results in ranked order
- **searchModal.ts**: Display interactive search interface, render results with highlighting, handle "jump to note" button interactions
- **main.ts**: Register the block search command, initialize plugin, cleanup on unload
- **types.ts**: Shared TypeScript interfaces for Block, SearchResult, and plugin settings

## File Structure After Implementation

```
src/
  main.ts              # Plugin lifecycle, block-search command registration
  settings.ts          # BlockSearchSettings interface and defaults
  types.ts             # Block, SearchResult interfaces
  blocks/
    parser.ts          # extractBlocksFromMarkdown function
    searcher.ts        # searchBlocks, loadAllBlocks functions
  ui/
    searchModal.ts     # SearchModal class implementation
```

## Testing Checklist

- [ ] `npm run build` succeeds without errors
- [ ] Plugin loads in Obsidian without console errors
- [ ] Block Search command appears in command palette
- [ ] Search modal opens and displays results for common queries
- [ ] Results are accurate and highlight terms correctly
- [ ] "Jump to note" button navigates to correct file and line
- [ ] Modal closes when ESC pressed
- [ ] Plugin unloads cleanly without memory leaks
- [ ] Search works on vault with 10+, 50+, 100+ notes (performance check)

## Iteration Path

### MVP (Phase 1): Core search working
- ✅ Types and interfaces
- ✅ Regex-based block parser
- ✅ Simple search with case-insensitive partial matching
- ✅ Modal UI with result list and jump-to-note

### Polish (Phase 2): Settings and refinement
- ✅ Add case-sensitive toggle setting
- ✅ Improve result ranking (file matches first)
- ✅ Syntax highlighting for block preview
- ⚠️ Consider caching if performance issues arise

### Enhancement (Phase 3): Advanced features
- ⚠️ Nested block navigation
- ⚠️ Advanced search filters (folder scope, block level)
- ⚠️ Search history and saved queries
